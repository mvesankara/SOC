from pydantic import BaseModel, ConfigDict
from typing import Optional, List
from datetime import datetime
from .models import CriticiteLevel, StatutIncident # Reusing enums from SQLAlchemy model

# Pydantic models (schemas) for API request/response validation and serialization

class IncidentBase(BaseModel):
    title: str
    criticite: CriticiteLevel
    statut: StatutIncident
    type: Optional[str] = None
    source: Optional[str] = None

class IncidentCreate(IncidentBase):
    # No extra fields needed for creation beyond what's in IncidentBase for now
    # Timestamp will be auto-generated by the database or application logic
    pass

class IncidentUpdate(BaseModel):
    title: Optional[str] = None
    criticite: Optional[CriticiteLevel] = None
    statut: Optional[StatutIncident] = None
    type: Optional[str] = None
    source: Optional[str] = None

class IncidentRead(IncidentBase):
    id: int
    timestamp: datetime

    # Pydantic V2 config for ORM mode
    model_config = ConfigDict(from_attributes=True)

# For listing multiple incidents
class IncidentList(BaseModel):
    items: List[IncidentRead]
    total: int
    # Add skip, limit if you want to return them in the response
    # skip: int
    # limit: int

# --- User Schemas ---

class UserBase(BaseModel):
    username: str
    email: Optional[str] = None

class UserCreate(UserBase):
    password: str # Plain password, will be hashed before saving

class UserUpdate(BaseModel): # For updating user info, not password here
    email: Optional[str] = None
    is_active: Optional[bool] = None
    is_superuser: Optional[bool] = None

class UserRead(UserBase):
    id: int
    is_active: bool
    is_superuser: bool

    model_config = ConfigDict(from_attributes=True) # For ORM mode

# Schema for changing password
class UserPasswordChange(BaseModel):
    old_password: str
    new_password: str

# --- Token Schemas ---

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    # You can add other fields here like user_id, roles, etc.

# --- Dashboard Schemas ---

class ThreatActivityTrend(BaseModel):
    labels: List[str]
    data: List[int]

class DashboardStats(BaseModel):
    open_incidents: int
    closed_incidents_last_24h: int
    new_incidents_last_24h: int
    critical_open_incidents: int
    resolved_incident_percentage: float
    threat_activity_trend: ThreatActivityTrend
    sla_compliance_percentage: str  # Keeping as str for "N/A"
    avg_response_time_minutes: str  # Keeping as str for "N/A"

class SystemStatus(BaseModel):
    name: str
    status: str # e.g., "Online", "Warning", "Offline"
    cpu: Optional[str] = None
    memory: Optional[str] = None
    monitored: Optional[int] = None # For Endpoints system type
    issues: Optional[int] = None    # For Endpoints system type
